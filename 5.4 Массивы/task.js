// Задачи
// Скопирован ли массив?
//     важность: 3
// Что выведет следующий код?

//     let fruits = ["Яблоки", "Груша", "Апельсин"];
//
// // добавляем новое значение в "копию"
// let shoppingCart = fruits;
// shoppingCart.push("Банан");
//
// for (i = 0; i < fruits.length; i++) {
//     alert(shoppingCart[i]);
// }
//
// // что в fruits?
// alert( fruits.length ); // 4

// Операции с массивами
// важность: 5
// Давайте произведём 5 операций с массивом.
//
//     Создайте массив styles с элементами «Джаз» и «Блюз».
// Добавьте «Рок-н-ролл» в конец.
//     Замените значение в середине на «Классика». Ваш код для поиска значения в середине должен работать для массивов с любой длиной.
//     Удалите первый элемент массива и покажите его.
//     Вставьте «Рэп» и «Регги» в начало массива.
//     Массив по ходу выполнения операций:
//
//     Джаз, Блюз
// Джаз, Блюз, Рок-н-ролл
// Джаз, Классика, Рок-н-ролл
// Классика, Рок-н-ролл
// Рэп, Регги, Классика, Рок-н-ролл


// let styles = ["Djaz", "Bluz"];
//
// styles.push("Roch-n-roll");
// styles[1] = "Classik";//Замените значение в середине на «Классика».
// alert( styles.shift()); // Удалите первый элемент массива и покажите его.
//
// styles.unshift('Rap', 'Reggi');
//
// for ( i = 0; i < styles.length; i++) {
//     alert(styles[i]);
// }
//
//
// alert(styles);
//


// Second variant
// let styles = ["Джаз", "Блюз"];
// styles.push("Рок-н-ролл");
// styles[Math.floor((styles.length - 1) / 2)] = "Классика";
// alert( styles.shift() );
// styles.unshift("Рэп", "Регги");

// Вызов в контексте массива
// важность: 5
// Каков результат? Почему?

// Вызов arr[2]() синтаксически – старый добрый obj[method](), в роли obj – arr, а в роли method – 2.
//
// Итак, у нас есть вызов функции arr[2] как метода объекта. Соответственно, он получает в качестве this объект arr и выводит массив:
//
//     let arr = ["a", "b"];
//
// arr.push(function() {
//     alert( this );
// });
// arr.push(function() {
//     alert(this);
// });
//
//
// arr[2](); // "a","b",function
// arr[3]();
// // У массива в итоге 3 элемента: сначала их было 2, плюс функция.

// Cумма введённых чисел
// важность: 4
// Напишите функцию sumInput(), которая:
//
// Просит пользователя ввести значения, используя prompt и сохраняет их в массив.
//     Заканчивает запрашивать значения, когда пользователь введёт не числовое значение, пустую строку или нажмёт «Отмена».
// Подсчитывает и возвращает сумму элементов массива.
//     P.S. Ноль 0 – считается числом, не останавливайте ввод значений при вводе «0».

// function sumInput() {
//     let numbers = [];
//
//     while (true) {
//         let value = prompt ("Введите число", 0);
//
//         // Прекращаем ввод?
//         if (value === "" || value === null || !isFinite(value)) break;
//
//         numbers.push(+value);
//     }
//
//     let sum = 0;
//     for (let number of numbers) {
//         sum +=number;
//     }
//     return sum;
// }

// alert(sumInput());


// Подмассив наибольшей суммы
// важность: 2
// На входе массив чисел, например: arr = [1, -2, 3, 4, -9, 6].
//
//     Задача: найти непрерывный подмассив в arr, сумма элементов в котором максимальна.
//
//     Функция getMaxSubSum(arr) должна возвращать эту сумму.
//
//     Например:
//
// getMaxSubSum([-1, 2, 3, -9]) = 5 (сумма выделенных)
// getMaxSubSum([2, -1, 2, 3, -9]) = 6
// getMaxSubSum([-1, 2, 3, -9, 11]) = 11
// getMaxSubSum([-2, -1, 1, 2]) = 3
// getMaxSubSum([100, -9, 2, -3, 5]) = 100
// getMaxSubSum([1, 2, 3]) = 6 (берём все)
// Если все элементы отрицательные – ничего не берём(подмассив пустой) и сумма равна «0»:
//
// getMaxSubSum([-1, -2, -3]) = 0
// Попробуйте придумать быстрое решение: O(n2), а лучше за О(n) операций.
//
